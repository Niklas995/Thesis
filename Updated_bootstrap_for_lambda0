    def bootstrap(self, bs_steps, U_save, beta, rho,  Nt, Ns, N_f):
        U_bs = np.zeros([bs_steps, int((self.updates -  self.skip) / self.intervall), 2, Nt, Ns])
        m = np.arange(-1., 1.3, 0.04)
        
        ov_scal = np.zeros([bs_steps, len(m)], dtype=complex)
        for b in range (0, bs_steps):
            for k in range (0,int((self.updates - self.skip) / self.intervall-2)):
                r = random.randint(0, int((self.updates - self.skip) / self.intervall-2))
                U_new_configs[k,:,:,:] = U_save[r,:,:,:]
            ov_condensate[b] = self.condensates(U_new_config , m, rho, beta, Nt, Ns, N_f)
        
        err_ov_condensate = np.std(ov_condensate, axis = 0)
        
        return ov_condensate[0], err_ov_condensate m
    



    def condensates(self, U_configs , m, rho, beta, Nt, Ns, N_f):
        ov_numerator   = np.zeros([len(m)], dtype=complex)
        ov_denumerator = np.zeros([len(m)], dtype=complex)
       	ov_m0_configs =  np.zeros([len(m)], dtype=complex)
        ov_condensate = np.zeros(len(m), dtype=complex)
        
        for i in range (0, int((self.updates - self.skip) / self.intervall)): 
            evo = self.Evo(U_configs[i], rho, Nt, Ns)  #massless staggered ev m=0
            
            for j in range(0, len(m)):
          
                if 0 not in evo:											#configs with evo != 0 
                    numerator,denumerator = 0.,0.
                    numerator , denumerator = self.ov_scal_de_numerator(evo, m[j], rho, beta, Nt, Ns, N_f)
                    ov_numerator[j] += numerator
                    ov_denumerator[j] += denumerator 
               														#configs with evo[i] = 0   
                if 0 in evo:
                    ov_m0_congigs[j] += 1
                    
            
   	for j in range (0, len(m)):
            ov_condensate[j] = np.sqrt(beta)/(Nt*Ns*Nt*Ns) * ((ov_numerator[j] + ov_m0_configs[j]) / ov_denumerator[j])       #add terms with evo[i]=0 and terms without evo[i] = 0
        return ov_condensate

    def ov_scal_de_numerator(self, evo, m, rho, beta, Nt, Ns, N_f):
        primed_sum = 0 
        for i in range (1, Nt*Ns*2):
            if np.real(evo[i]) != 2*rho:
                lambda_tilde = 2*rho*evo[i]/(2*rho-evo[i])
                primed_sum += (lambda_tilde.real + m)/(lambda_tilde * np.conj(lambda_tilde) + m*m + 2*m*lambda_tilde.real)
        det = 1 
        for i in range (1, Nt*Ns*2):
            det *= ((1 - m / (2 * rho)) * evo[i] + m)
        
 	numerator =  pow(det, N_f)*primed_sum 
        denumerator = pow(det, N_f)

        return numerator, denumerator
    
    
